import java.io.IOException
//Here, we are going to see an Exceptions in Kotlin...
//In, Kotlin there is no difference between Checked(compile time) & Un-checked(run time) exceptions both are treated as same here...
//We, don't need to specify an exception that can be thrown from our Kotlin function coz we are not going to handle that unlike Java do...
//Throw(throw keyword) is an expression in Kotlin & we can assign that to any kind of variable it's very much possible...
fun main(){
//In, below code im just simply assign a throw(keyword) to the variable named n coz here throw is an expression ok...
    fun num(no:Int){
    //Here, the given number is anything between from 0 to 100 then it's ok fine it will return that particular number as a result as shown below...
   //But, if we give any number like above 100 & below 0 then it will throw an IllegalArgumentException as shown here...
        val n =
            if(no in 0..100)
                no
            else
                throw IllegalArgumentException(
                    "A number range must be " +
                            "between 0 to 100 but it's $no")
        println(n)
    }
  num(17) // Exception is not thrown...
   // num(360) // Here, the Exception is thrown...
    upToTwoDigitOnly(16) // Exception is not thrown...
  //  upToTwoDigitOnly(720) // Exception is thrown...
    parsingString("17")
    parsingString("AB")
    parsingString("16")
    parsingString("Mr.360")
    println()
    hi()
    hello()
}
fun upToTwoDigitOnly(dgt : Int){
 //In, below code im simply assign the result of a throw expression into a variable and throw can be used in 'if' & 'when' branches(conditions) especially as shown below...
    //Here, the digit is anything between from 0 to 99 then it's ok fine it will return that particular digit as a result as shown below...
     //But, if we give any three-digit number like 100,360 then it will throw an IllegalArgumentException as shown here...
    val number =
        if(dgt in 0..99)
            dgt
        else
            throw IllegalArgumentException(
                "Here, the given input value " +
                        "must be from '0' to '99' only. " +
                          "But, here the actually given " +
                            "input was $dgt!"
            )
    println(number)
}
//Like, throw 'try' is also an expression in Kotlin...
//We, can simply assign the result of try expression into variable very same like a throw was being done...
fun parsingString(str:String){
    //Here, below im just used to convert a given String value to Int value if conversion is perfect means then it will return the given String value in an Int value manner...
    //If, the conversion is not possible like we gave any String literals like "AB","Mr.360"etc., other than digits then it will return 'null' value as a result...
    val parsedNo =
        try{
            Integer.parseInt(str)
        }catch (e : Exception/*NumberFormatException*/){
             null
           // e.printStackTrace()
           // return
        }
    println("The Given String number is $parsedNo!")
}
//There, are no Checked(compile time) Exceptions in Kotlin...
//So, we doesn't need to specify the type of the exception that has been occurred in our respective Kotlin function...
//It, means there is no need to specify this kotlin function is used to throw this kind of exception ok...
//But, below '@Throws' annotation was used for those particular Kotlin functions which has been called from Java Classes ok...
//If, we call one Kotlin Function inside a Kotlin then there is no need to use '@Throws' annotation...
//But, if we are calling that Kotlin Function outside of Kotlin from Java then we must need to use '@Throws' annotation as shown below...
//Coz, in Java the exceptions that can't be going to catch by the 'try' block if it was not thrown ok...
//If, the exception was thrown then only the 'try' block in Java is Used to Catch that particular exception (or) otherwise no chance an error will be thrown...
@Throws(IOException::class)
fun hi(){
    throw IOException()
}
fun hello(){
    throw IOException()
}
/*
//Here, im just used to showcase why IOException from Kotlin was not handled by Using Java Class try block...
//Coz, it was not thrown by Kotlin by using '@Throws' annotation Java cannot handle the exception if it was not thrown ok...
import java.io.IOException;
public class UsingKotlinExceptions {
    public static void main(String[] args) {
        try{
            //Here, below the exception was caught by try block of Java Class coz that Exception was thrown by Kotlin using '@Throws' annotation...
            //So, the code below will compile without any problem...
            ExcepKt.hi();
            //Here, below the exception was not caught by try block of Java Class coz that Exception was not thrown by Kotlin using '@Throws' annotation...
            //So, the code below will not compile coz that IOException from Kotlin was not thrown by using '@Throws' annotation...
            //So, it will lead to compile time error...
            //ExcepKt.hello();
        }catch(IOException e){
            e.printStackTrace();
        }
    }
}
 */

